package org.hyperskill.musicplayer.internals;

@kotlin.Metadata(mv = {1, 9, 0}, k = 1, xi = 48, d1 = {"\u0000\u00a2\u0001\n\u0002\u0018\u0002\n\u0000\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0018\u0002\n\u0002\b\u0007\n\u0002\u0018\u0002\n\u0002\b\u0004\n\u0002\u0018\u0002\n\u0002\b\u0004\n\u0002\u0018\u0002\n\u0002\b\u0004\n\u0002\u0010\u0002\n\u0000\n\u0002\u0010\u000e\n\u0002\b\u0003\n\u0002\u0010 \n\u0000\n\u0002\u0010\b\n\u0000\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\b\u0004\n\u0002\u0018\u0002\n\u0000\n\u0002\u0018\u0002\n\u0000\n\u0002\u0018\u0002\n\u0002\b\u0002\n\u0002\u0018\u0002\n\u0002\b\u0003\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\b\u0004\n\u0002\u0018\u0002\n\u0002\b\u0006\n\u0002\u0010\t\n\u0002\b\b\n\u0002\u0018\u0002\n\u0002\b\u0002\b&\u0018\u0000*\b\b\u0000\u0010\u0001*\u00020\u00022\u00020\u0003B\u0013\u0012\f\u0010\u0004\u001a\b\u0012\u0004\u0012\u00028\u00000\u0005\u00a2\u0006\u0002\u0010\u0006J\u0016\u0010\u001b\u001a\u00020\u001c2\u0006\u0010\u001d\u001a\u00020\u001e2\u0006\u0010\u001f\u001a\u00020\u001eJ\u001e\u0010 \u001a\u00020\u001c2\f\u0010!\u001a\b\u0012\u0004\u0012\u00020\u001e0\"2\b\b\u0002\u0010#\u001a\u00020$J\u001a\u0010%\u001a\u000e\u0012\u0004\u0012\u00020\'\u0012\u0004\u0012\u00020(0&2\u0006\u0010)\u001a\u00020\u001eJ;\u0010*\u001a\u0002H+\"\u0004\b\u0001\u0010+2\b\b\u0002\u0010,\u001a\u00020-2\n\b\u0002\u0010.\u001a\u0004\u0018\u00010/2\u0012\u00100\u001a\u000e\u0012\u0004\u0012\u00020\u0002\u0012\u0004\u0012\u0002H+01\u00a2\u0006\u0002\u00102J{\u00103\u001a\u00020\u001c\"\u0004\b\u0001\u0010\u0001*\u0002042\f\u00105\u001a\b\u0012\u0004\u0012\u0002H\u00010\"2\b\b\u0002\u00106\u001a\u00020\u001e2Q\u00107\u001aM\u0012\u0019\u0012\u0017\u0012\u0004\u0012\u00020:09\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(=\u0012\u0013\u0012\u00110$\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(>\u0012\u0013\u0012\u0011H\u0001\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(?\u0012\u0004\u0012\u00020\u001c08J\u0090\u0001\u00103\u001a\u00020\u001c\"\u0004\b\u0001\u0010\u0001*\u0002042\f\u00105\u001a\b\u0012\u0004\u0012\u0002H\u00010\"2\b\b\u0002\u00106\u001a\u00020\u001e2f\u00107\u001ab\u0012\u0019\u0012\u0017\u0012\u0004\u0012\u00020:09\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(=\u0012\u0013\u0012\u00110$\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(>\u0012\u0013\u0012\u0011H\u0001\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(?\u0012\u0013\u0012\u00110$\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(A\u0012\u0004\u0012\u00020\u001c0@JE\u0010B\u001a\u00020\u001c*\u0002042\u0006\u0010C\u001a\u00020$2\b\b\u0002\u00106\u001a\u00020\u001e2\'\u0010D\u001a#\u0012\u0019\u0012\u0017\u0012\u0004\u0012\u00020:09\u00a2\u0006\f\b;\u0012\b\b<\u0012\u0004\b\b(=\u0012\u0004\u0012\u00020\u001c01J\u0014\u0010E\u001a\u00020$*\u00020:2\b\b\u0002\u0010F\u001a\u00020GJ\u0014\u0010H\u001a\u00020$*\u00020:2\b\b\u0002\u0010F\u001a\u00020GJ\u001c\u0010I\u001a\u00020$*\u00020\u00022\u0006\u0010J\u001a\u00020\u001e2\b\b\u0002\u0010F\u001a\u00020GJ\"\u0010K\u001a\u0002H\u0001\"\u0006\b\u0001\u0010\u0001\u0018\u0001*\u00020\u00022\u0006\u0010J\u001a\u00020\u001eH\u0086\b\u00a2\u0006\u0002\u0010LJ\"\u0010K\u001a\u0002H\u0001\"\u0006\b\u0001\u0010\u0001\u0018\u0001*\u00020:2\u0006\u0010J\u001a\u00020\u001eH\u0086\b\u00a2\u0006\u0002\u0010MJ$\u0010N\u001a\u0004\u0018\u0001H\u0001\"\u0006\b\u0001\u0010\u0001\u0018\u0001*\u00020:2\u0006\u0010J\u001a\u00020\u001eH\u0086\b\u00a2\u0006\u0002\u0010MJ\u0012\u0010O\u001a\u00020\u001c*\u00020P2\u0006\u0010Q\u001a\u00020$R\u001b\u0010\u0007\u001a\u00020\u00028FX\u0086\u0084\u0002\u00a2\u0006\f\n\u0004\b\n\u0010\u000b\u001a\u0004\b\b\u0010\tR!\u0010\f\u001a\b\u0012\u0004\u0012\u00028\u00000\r8FX\u0086\u0084\u0002\u00a2\u0006\f\n\u0004\b\u0010\u0010\u000b\u001a\u0004\b\u000e\u0010\u000fR\u001b\u0010\u0011\u001a\u00020\u00128FX\u0086\u0084\u0002\u00a2\u0006\f\n\u0004\b\u0015\u0010\u000b\u001a\u0004\b\u0013\u0010\u0014R\u001b\u0010\u0016\u001a\u00020\u00178FX\u0086\u0084\u0002\u00a2\u0006\f\n\u0004\b\u001a\u0010\u000b\u001a\u0004\b\u0018\u0010\u0019\u00a8\u0006R"}, d2 = {"Lorg/hyperskill/musicplayer/internals/AbstractUnitTest;", "T", "Landroid/app/Activity;", "", "clazz", "Ljava/lang/Class;", "(Ljava/lang/Class;)V", "activity", "getActivity", "()Landroid/app/Activity;", "activity$delegate", "Lkotlin/Lazy;", "activityController", "Lorg/robolectric/android/controller/ActivityController;", "getActivityController", "()Lorg/robolectric/android/controller/ActivityController;", "activityController$delegate", "shadowActivity", "Lorg/robolectric/shadows/ShadowActivity;", "getShadowActivity", "()Lorg/robolectric/shadows/ShadowActivity;", "shadowActivity$delegate", "shadowLooper", "Lorg/robolectric/shadows/ShadowLooper;", "getShadowLooper", "()Lorg/robolectric/shadows/ShadowLooper;", "shadowLooper$delegate", "assertLastToastMessageEquals", "", "errorMessage", "", "expectedMessage", "assertRequestPermissions", "permissionsRequired", "", "expectedRequestCode", "", "getLastAlertDialogWithShadow", "Lkotlin/Pair;", "Landroid/app/AlertDialog;", "Lorg/robolectric/shadows/ShadowAlertDialog;", "errorMessageNotFound", "testActivity", "ReturnValue", "arguments", "Landroid/content/Intent;", "savedInstanceState", "Landroid/os/Bundle;", "testCodeBlock", "Lkotlin/Function1;", "(Landroid/content/Intent;Landroid/os/Bundle;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;", "assertListItems", "Landroidx/recyclerview/widget/RecyclerView;", "fakeResultList", "caseDescription", "assertItems", "Lkotlin/Function3;", "Lkotlin/Function0;", "Landroid/view/View;", "Lkotlin/ParameterName;", "name", "itemViewSupplier", "position", "item", "Lkotlin/Function4;", "elapsedTime", "assertSingleListItem", "itemIndex", "action", "clickAndRun", "millis", "", "clickLongAndRun", "clickMenuItemAndRun", "idString", "findViewByString", "(Landroid/app/Activity;Ljava/lang/String;)Ljava/lang/Object;", "(Landroid/view/View;Ljava/lang/String;)Ljava/lang/Object;", "findViewByStringOrNull", "setProgressAsUser", "Landroid/widget/SeekBar;", "progress", "Music_Player-task_debugUnitTest"})
public abstract class AbstractUnitTest<T extends android.app.Activity> {
    
    /**
     * Setup and control activities and their lifecycle
     */
    @org.jetbrains.annotations.NotNull()
    private final kotlin.Lazy activityController$delegate = null;
    
    /**
     * The activity being tested.
     *
     * It is the @RealObject of the shadowActivity
     */
    @org.jetbrains.annotations.NotNull()
    private final kotlin.Lazy activity$delegate = null;
    
    /**
     * A Roboletric shadow object of the Activity class, contains helper methods to deal with
     * testing activities like setting permissions, peeking results of launched activities for result,
     * retrieving shown dialogs, intents and others.
     *
     * If you don't know what shadows are you can have a better understanding on that reading this
     * on roboletric documentation: http://robolectric.org/extending/
     *
     * Understanding Shadows is fundamental for Roboletric, things are not what they appear to be on
     * Roboletric because running a code on the jvm is not the same as running the code on a real/emulated device.
     * Code that expects to eventually talk to the machine won't have the machine they expect to have to talk to.
     * Shadow is how Roboletric makes things possible, they impersonate @RealObject and act when @RealObject is expected to act.
     *
     * Things in Roboletric are not what they appear to be.
     * It is possible to not notice it for the most part, but it will be essential for some other parts
     */
    @org.jetbrains.annotations.NotNull()
    private final kotlin.Lazy shadowActivity$delegate = null;
    
    /**
     * A Roboletric shadow object of the mainLooper. Handles enqueued runnables and also the passage of time.
     *
     * Usually used with .idleFor(someDurationValue) or .runToEndOfTasks()
     */
    @org.jetbrains.annotations.NotNull()
    private final kotlin.Lazy shadowLooper$delegate = null;
    
    public AbstractUnitTest(@org.jetbrains.annotations.NotNull()
    java.lang.Class<T> clazz) {
        super();
    }
    
    /**
     * Setup and control activities and their lifecycle
     */
    @org.jetbrains.annotations.NotNull()
    public final org.robolectric.android.controller.ActivityController<T> getActivityController() {
        return null;
    }
    
    /**
     * The activity being tested.
     *
     * It is the @RealObject of the shadowActivity
     */
    @org.jetbrains.annotations.NotNull()
    public final android.app.Activity getActivity() {
        return null;
    }
    
    /**
     * A Roboletric shadow object of the Activity class, contains helper methods to deal with
     * testing activities like setting permissions, peeking results of launched activities for result,
     * retrieving shown dialogs, intents and others.
     *
     * If you don't know what shadows are you can have a better understanding on that reading this
     * on roboletric documentation: http://robolectric.org/extending/
     *
     * Understanding Shadows is fundamental for Roboletric, things are not what they appear to be on
     * Roboletric because running a code on the jvm is not the same as running the code on a real/emulated device.
     * Code that expects to eventually talk to the machine won't have the machine they expect to have to talk to.
     * Shadow is how Roboletric makes things possible, they impersonate @RealObject and act when @RealObject is expected to act.
     *
     * Things in Roboletric are not what they appear to be.
     * It is possible to not notice it for the most part, but it will be essential for some other parts
     */
    @org.jetbrains.annotations.NotNull()
    public final org.robolectric.shadows.ShadowActivity getShadowActivity() {
        return null;
    }
    
    /**
     * A Roboletric shadow object of the mainLooper. Handles enqueued runnables and also the passage of time.
     *
     * Usually used with .idleFor(someDurationValue) or .runToEndOfTasks()
     */
    @org.jetbrains.annotations.NotNull()
    public final org.robolectric.shadows.ShadowLooper getShadowLooper() {
        return null;
    }
    
    /**
     * Sets up activity for tests and ensures better error messages displayed
     * when tests are run with check button and exceptions are thrown by user implementation.
     *
     * returns a value for convenience use, like in tests that involve navigation between Activities
     */
    public final <ReturnValue extends java.lang.Object>ReturnValue testActivity(@org.jetbrains.annotations.NotNull()
    android.content.Intent arguments, @org.jetbrains.annotations.Nullable()
    android.os.Bundle savedInstanceState, @org.jetbrains.annotations.NotNull()
    kotlin.jvm.functions.Function1<? super android.app.Activity, ? extends ReturnValue> testCodeBlock) {
        return null;
    }
    
    /**
     * Use this method to perform clicks. It will also advance the clock millis milliseconds and run
     * enqueued Runnable scheduled to run on main looper in that timeframe.
     * Default value for millis is 500.
     *
     * Internally it calls performClick(), which might or might not increase clock time by itself
     * depending on the actions performed during click. If possible the amount of millis will
     * be corrected on the call to shadowLooper.idleFor(millis), but it is not possible to idleFor
     * negative values, which means it is not always possible to increase 0 millis.
     *
     * Returns the actual amount increased to help keep track of time elapsed.
     */
    public final int clickAndRun(@org.jetbrains.annotations.NotNull()
    android.view.View $this$clickAndRun, long millis) {
        return 0;
    }
    
    /**
     * Use this method to perform long clicks. It will also advance the clock millis milliseconds and run
     * enqueued Runnable scheduled to run on main looper in that timeframe.
     * Default value for millis is 500
     *
     * Internally it calls performLongClick(), which might or might not increase clock time by itself
     * depending on the actions performed during click. If possible the amount of millis will
     * be corrected on the call to shadowLooper.idleFor(millis), but it is not possible to idleFor
     * negative values, which means it is not always possible to increase 0 millis.
     *
     * Returns the actual amount increased to help keep track of time elapsed.
     */
    public final int clickLongAndRun(@org.jetbrains.annotations.NotNull()
    android.view.View $this$clickLongAndRun, long millis) {
        return 0;
    }
    
    /**
     * Asserts that the last message toasted is the expectedMessage.
     * Assertion fails if no toast is shown with null actualLastMessage value.
     */
    public final void assertLastToastMessageEquals(@org.jetbrains.annotations.NotNull()
    java.lang.String errorMessage, @org.jetbrains.annotations.NotNull()
    java.lang.String expectedMessage) {
    }
    
    /**
     * Use this method to set the progress as a user.
     *
     * Will trigger attached listeners.
     *
     * First onStartTrackingTouch(), then onProgressChanged() as user, and finally onStopTrackingTouch()
     */
    public final void setProgressAsUser(@org.jetbrains.annotations.NotNull()
    android.widget.SeekBar $this$setProgressAsUser, int progress) {
    }
    
    /**
     * Use this method to make assertions on requisition of permissions
     *
     * @param permissionsRequired list of requiredPermission, ex: listOf(Manifest.permission.READ_EXTERNAL_STORAGE)
     * @param expectedRequestCode requestCode that test expect implementation to use in their code
     */
    public final void assertRequestPermissions(@org.jetbrains.annotations.NotNull()
    java.util.List<java.lang.String> permissionsRequired, int expectedRequestCode) {
    }
    
    /**
     * Use this method to perform clicks on menu items.
     *
     * It will assert the existence of the identifier. If the identifier exists but is not
     * a menu item then the assertion will succeed, but no click will be performed.
     *
     * Will also advance the clock millis milliseconds and run
     * enqueued Runnable scheduled to run on main looper in that timeframe.
     * Default value for millis is 500
     */
    public final int clickMenuItemAndRun(@org.jetbrains.annotations.NotNull()
    android.app.Activity $this$clickMenuItemAndRun, @org.jetbrains.annotations.NotNull()
    java.lang.String idString, long millis) {
        return 0;
    }
    
    /**
     * Retrieve last shown AlertDialog.
     *
     * Will only find android.app.AlertDialog and not androidx.appcompat.app.AlertDialog
     *
     * Returns the AlertDialog instance paired with its shadow
     */
    @org.jetbrains.annotations.NotNull()
    public final kotlin.Pair<android.app.AlertDialog, org.robolectric.shadows.ShadowAlertDialog> getLastAlertDialogWithShadow(@org.jetbrains.annotations.NotNull()
    java.lang.String errorMessageNotFound) {
        return null;
    }
    
    /**
     * Makes assertions on the contents of the RecyclerView.
     *
     * Asserts that the size matches the size of fakeResultList and then
     * calls assertItems for each item of the list with the itemViewSupplier
     * so that it is possible to make assertions on that itemView.
     *
     * Take attention to refresh references to views coming from itemView since RecyclerView
     * can change the instance of View for a determinate list item after an update to the list.
     */
    public final <T extends java.lang.Object>void assertListItems(@org.jetbrains.annotations.NotNull()
    androidx.recyclerview.widget.RecyclerView $this$assertListItems, @org.jetbrains.annotations.NotNull()
    java.util.List<? extends T> fakeResultList, @org.jetbrains.annotations.NotNull()
    java.lang.String caseDescription, @org.jetbrains.annotations.NotNull()
    kotlin.jvm.functions.Function3<? super kotlin.jvm.functions.Function0<? extends android.view.View>, ? super java.lang.Integer, ? super T, kotlin.Unit> assertItems) {
    }
    
    /**
     * Makes assertions on the contents of the RecyclerView.
     *
     * Asserts that the size matches the size of fakeResultList and then
     * calls assertItems for each item of the list with the itemViewSupplier
     * so that it is possible to make assertions on that itemView.
     *
     * Take attention to refresh references to views coming from itemView since RecyclerView
     * can change the instance of View for a determinate list item after an update to the list.
     *
     * This version also includes elapsedTime on the callBack to help keep track of time
     * since the clock might advance
     */
    public final <T extends java.lang.Object>void assertListItems(@org.jetbrains.annotations.NotNull()
    androidx.recyclerview.widget.RecyclerView $this$assertListItems, @org.jetbrains.annotations.NotNull()
    java.util.List<? extends T> fakeResultList, @org.jetbrains.annotations.NotNull()
    java.lang.String caseDescription, @org.jetbrains.annotations.NotNull()
    kotlin.jvm.functions.Function4<? super kotlin.jvm.functions.Function0<? extends android.view.View>, ? super java.lang.Integer, ? super T, ? super java.lang.Integer, kotlin.Unit> assertItems) {
    }
    
    /**
     * Makes assertions on the contents of one item of the RecyclerView.
     *
     * Asserts that the the size of the list is at least itemIndex + 1.
     *
     * Calls assertItem with the itemViewSupplier so that it is possible to make assertions on that itemView.
     * Take attention to refresh references to views coming from itemView since RecyclerView
     * can change the instance of View for a determinate list item after an update to the list.
     */
    public final void assertSingleListItem(@org.jetbrains.annotations.NotNull()
    androidx.recyclerview.widget.RecyclerView $this$assertSingleListItem, int itemIndex, @org.jetbrains.annotations.NotNull()
    java.lang.String caseDescription, @org.jetbrains.annotations.NotNull()
    kotlin.jvm.functions.Function1<? super kotlin.jvm.functions.Function0<? extends android.view.View>, kotlin.Unit> action) {
    }
}